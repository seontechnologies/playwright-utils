import { promises as fs } from 'node:fs'
import path from 'node:path'
import { extractText, getDocumentProxy, getMeta } from 'unpdf'
import type { PDFReadOptions, PDFReadResult } from './types'

// Note: unpdf uses PDF.js internally but doesn't expose proper TypeScript types
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type PDFDocumentType = any

const DEFAULT_OPTIONS: PDFReadOptions = {
  extractText: true,
  maxPages: undefined,
  debug: false,
  mergePages: true
}

/**
 * Reads and extracts text from a PDF file, with optional page merging and debug control.
 *
 * @remarks
 * - Fallbacks between merged and unmerged extraction.
 * - Vector-based PDFs (e.g., jsPDF) may fail check `info.isVectorBased` and `info.extractionNotes`.
 *
 * @param options.filePath                   Path to the PDF file.
 * @param options.maxPages                   Max pages to read (default: all).
 * @param options.debug                      Enable debug logging (default: false).
 * @param options.maxPages                   Max pages to read (default: all).
 *
 * @returns A `PDFReadResult` containing:
 *   - `content`: extracted text
 *   - `pagesCount`: total number of pages
 *   - `info`: metadata & extraction details
 *   - `metadata`: raw PDF metadata
 *
 * @example
 * ```typescript
 * // Simple usage - extract all text as single string
 * const result = await readPDF({
 *   filePath: '/path/to/document.pdf'
 * })
 * ```
 *
 * @example
 * ```typescript
 * // Advanced usage with all options
 * const result = await readPDF({
 *   filePath: '/path/to/document.pdf',
 *   mergePages: false,  // Keep pages separate (joined with \n)
 *   debug: true,        // Enable debug logging
 *   maxPages: 10        // Limit processing to first 10 pages
 * })
 * ```
 */
export async function readPDF(
  options: PDFReadOptions & { filePath: string }
): Promise<PDFReadResult> {
  const mergedOptions = { ...DEFAULT_OPTIONS, ...options }

  try {
    const dataBuffer = await fs.readFile(options.filePath)
    const pdf = await getDocumentProxy(new Uint8Array(dataBuffer))
    const meta = await getMeta(pdf)
    const content = await tryExtractionStrategies(pdf, mergedOptions)
    const pdfInfo = meta.info
    const extractionSuccess = content.length > 0

    // Only calculate vector-based detection and notes if extraction failed
    let isVectorBased: boolean | undefined
    let extractionNotes: string | undefined

    if (!extractionSuccess) {
      isVectorBased =
        pdfInfo?.Producer?.includes('jsPDF') ||
        (pdfInfo?.Creator?.includes('jsPDF') && !content?.trim())

      extractionNotes = isVectorBased
        ? 'This PDF appears to be vector-based (generated by jsPDF or similar). ' +
          'Text extraction from vector-based PDFs is not supported. ' +
          'Consider using a different PDF generation method that embeds text.'
        : 'Text extraction failed. The PDF may be encrypted, corrupted, or use an unsupported format.'
    }

    return {
      filePath: options.filePath,
      fileName: path.basename(options.filePath),
      extension: 'pdf',
      content,
      pagesCount: pdf.numPages,
      info: {
        ...meta.info,
        textExtractionSuccess: extractionSuccess,
        extractionMethod: extractionSuccess ? 'unpdf' : 'failed',
        ...(isVectorBased !== undefined && { isVectorBased }), // Only include if calculated
        ...(extractionNotes && { extractionNotes }) // Only include if we have notes
      },
      metadata: meta.metadata || {}
    }
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to read PDF file: ${error.message}`)
    }
    throw error
  }
}

/** Try multiple extraction strategies to get text from a PDF */
async function tryExtractionStrategies(
  pdf: PDFDocumentType,
  options: PDFReadOptions
): Promise<string> {
  const userMergePages = options.mergePages ?? true

  // Strategy 1: User's preferred mergePages setting
  try {
    const content = await extractWithMergePagesSetting(pdf, userMergePages)
    if (content && content.trim().length > 0) {
      return content
    }
  } catch {
    // Continue to next strategy
  }

  // Strategy 2: Opposite mergePages setting
  try {
    const content = await extractWithMergePagesSetting(pdf, !userMergePages)
    if (content && content.trim().length > 0) {
      return content
    }
  } catch {
    // Continue to fallback
  }

  return ''
}

/** Extract text using the unpdf extractText function */
async function extractWithMergePagesSetting(
  pdf: PDFDocumentType,
  mergePages: boolean
): Promise<string> {
  if (mergePages) {
    const result = await extractText(pdf, { mergePages: true })
    return result.text || ''
  } else {
    const result = await extractText(pdf, { mergePages: false })
    const textArray = result.text || []
    return Array.isArray(textArray) ? textArray.join('\n') : String(textArray)
  }
}
