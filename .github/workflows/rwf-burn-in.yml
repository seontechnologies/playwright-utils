name: 'Detect-and-Burn-in Reusable'

on:
  workflow_call:
    outputs:
      runE2E:
        description: 'Whether to run E2E tests'
        value: ${{ jobs.burn-in-rwf.outputs.runE2E }}
    inputs:
      base-ref:
        type: string
        description: 'Base ref to compare changed files with HEAD'
        default: 'main'
      test-directory:
        type: string
        description: 'Directory containing test files and burn-in script'
        default: 'playwright/'
      install-command:
        type: string
        description: 'Dependency install command'
        default: 'npm ci'

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  burn-in-rwf:
    runs-on: kubernetes-default
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        shardIndex: [1, 2]
        shardTotal: [2]
    permissions:
      id-token: write
      contents: read
      packages: read
    outputs:
      runE2E: ${{ steps.burn-in-result.outputs.runE2E }}
    steps:
      # Always check out code first before using any local actions
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: '0'
          
      # Use the install composite action
      - name: Setup Node and Install Dependencies
        uses: ./.github/actions/install
        with:
          install-command: ${{ inputs.install-command }}
          node-version-file: '.nvmrc'

      #######################################################################
      #  ↓↓↓  PLAYWRIGHT BROWSER CACHING ↓↓↓
      #######################################################################
      # Use the setup-playwright-browsers composite action
      - name: Setup Playwright browsers
        id: setup-pw
        uses: ./.github/actions/setup-playwright-browsers
        with:
          browser-cache-bust: ${{ github.event.inputs.browser_cache_bust }}
      #######################################################################
      #  ↑↑↑  PLAYWRIGHT BROWSER CACHING ↑↑↑
      #######################################################################

      # Setup Kafka with the composite action
      - name: Setup Kafka
        id: setup-kafka
        uses: ./.github/actions/setup-kafka
        with:
          kafka-compose-file: ./sample-app/backend/src/events/kafka-cluster.yml
          health-check-script: ./sample-app/backend/scripts/kafka-health-check.js
          continue-on-error: true

      - name: Run Smart Burn-in
        id: burn-in-step
        working-directory: ${{ inputs.test-directory }}
        env:
          CI: 'true'
          ALLOW_KAFKA_FAILURE: 'true'
          PW_BURN_IN: true
        run: |
          # Ensure base branch is available
          git branch -f ${{ inputs.base-ref }} origin/${{ inputs.base-ref }}
          
          # Use smart burn-in script - it handles all decision logic internally
          # Note: Smart burn-in generates appropriate commands, but we still apply sharding at workflow level
          npx tsx scripts/burn-in-changed.ts --base-branch=${{ inputs.base-ref }} --shard=${{ matrix.shardIndex }}/${{ matrix.shardTotal }}

      # Stop Kafka after tests
      - name: Stop Kafka
        continue-on-error: true
        if: always()
        run: docker compose -f ./sample-app/backend/src/events/kafka-cluster.yml down

      - name: Set E2E execution result
        id: burn-in-result
        if: always()
        run: |
          if [ "${{ steps.burn-in-step.outcome }}" = "success" ]; then
            echo "runE2E=true" >> $GITHUB_OUTPUT
            echo "✅ Smart burn-in completed successfully => E2E can proceed"
          else
            echo "runE2E=false" >> $GITHUB_OUTPUT
            echo "❌ Smart burn-in failed => E2E will be skipped"
          fi
